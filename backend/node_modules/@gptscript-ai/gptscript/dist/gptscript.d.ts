export interface GlobalOpts {
    APIKey?: string;
    BaseURL?: string;
    DefaultModel?: string;
    DefaultModelProvider?: string;
    Env?: string[];
}
export interface RunOpts {
    input?: string;
    disableCache?: boolean;
    quiet?: boolean;
    chdir?: string;
    subTool?: string;
    workspace?: string;
    chatState?: string;
    confirm?: boolean;
    prompt?: boolean;
    credentialOverrides?: string[];
    location?: string;
    env?: string[];
    forceSequential?: boolean;
    APIKey?: string;
    BaseURL?: string;
    DefaultModel?: string;
}
export declare enum RunEventType {
    Event = "event",
    RunStart = "runStart",
    RunFinish = "runFinish",
    CallStart = "callStart",
    CallChat = "callChat",
    CallSubCalls = "callSubCalls",
    CallProgress = "callProgress",
    CallConfirm = "callConfirm",
    CallContinue = "callContinue",
    CallFinish = "callFinish",
    Prompt = "prompt"
}
export declare class GPTScript {
    private static serverURL;
    private static serverProcess;
    private static instanceCount;
    private ready;
    constructor(opts?: GlobalOpts);
    close(): void;
    listTools(): Promise<string>;
    listModels(): Promise<string>;
    version(): Promise<string>;
    runBasicCommand(cmd: string): Promise<string>;
    /**
     * Runs a tool with the specified name and options.
     *
     * @param {string} toolName - The name of the tool to run. Can be a file path, URL, or GitHub URL.
     * @param {RunOpts} [opts={}] - The options for running the tool.
     * @return {Run} The Run object representing the running tool.
     */
    run(toolName: string, opts?: RunOpts): Promise<Run>;
    /**
     * Evaluates the given tool and returns a Run object.
     *
     * @param {ToolDef | ToolDef[]} tool - The tool to be evaluated. Can be a single ToolDef object or an array of ToolDef objects.
     * @param {RunOpts} [opts={}] - Optional options for the evaluation.
     * @return {Run} The Run object representing the evaluation.
     */
    evaluate(tool: ToolDef | ToolDef[], opts?: RunOpts): Promise<Run>;
    parse(fileName: string): Promise<Block[]>;
    parseTool(toolContent: string): Promise<Block[]>;
    stringify(blocks: Block[]): Promise<string>;
    confirm(response: AuthResponse): Promise<void>;
    promptResponse(response: PromptResponse): Promise<void>;
    private testGPTScriptURL;
}
export declare class Run {
    readonly id: string;
    readonly opts: RunOpts;
    readonly tools?: ToolDef | ToolDef[] | string;
    state: RunState;
    calls: Record<string, CallFrame>;
    err: string;
    protected stdout?: string;
    private readonly gptscriptURL?;
    private readonly requestPath;
    private promise?;
    private req?;
    private stderr?;
    private callbacks;
    private chatState?;
    private parentCallId;
    private prg?;
    private respondingToolId?;
    constructor(subCommand: string, tools: ToolDef | ToolDef[] | string, opts: RunOpts, gptscriptURL?: string);
    nextChat(input?: string): Run;
    processStdout(data: string | object): string;
    request(tool: any): void;
    requestNoStream(tool: any): void;
    requestOptions(gptscriptURL: string, path: string, tool: any): {
        hostname: string;
        port: string | number;
        protocol: string;
        path: string;
        method: string;
        headers: {
            "Content-Type": string;
        };
    };
    on(event: RunEventType.RunStart | RunEventType.RunFinish, listener: (data: RunFrame) => void): this;
    on(event: RunEventType.CallStart | RunEventType.CallProgress | RunEventType.CallContinue | RunEventType.CallChat | RunEventType.CallConfirm | RunEventType.CallFinish, listener: (data: CallFrame) => void): this;
    on(event: RunEventType.Prompt, listener: (data: PromptFrame) => void): this;
    on(event: RunEventType.Event, listener: (data: Frame) => void): this;
    text(): Promise<string>;
    json(): Promise<any>;
    currentChatState(): string | undefined;
    parentCallFrame(): CallFrame | undefined;
    program(): Program | undefined;
    respondingTool(): Tool | undefined;
    close(): void;
    private emitEvent;
    private emit;
}
export type Arguments = string | Record<string, string>;
export declare const ArgumentSchemaType: "object";
export interface ArgumentSchema {
    type: typeof ArgumentSchemaType;
    properties?: Record<string, Property>;
    required?: string[];
}
export interface Program {
    name: string;
    toolSet: Record<string, Tool>;
    openAPICache: Record<string, any>;
}
export declare const PropertyType: "string";
export interface Property {
    type: typeof PropertyType;
    description: string;
    default?: string;
}
export interface Repo {
    VCS: string;
    Root: string;
    Path: string;
    Name: string;
    Revision: string;
}
export interface ToolDef {
    name?: string;
    description?: string;
    maxTokens?: number;
    modelName?: string;
    modelProvider?: boolean;
    jsonResponse?: boolean;
    temperature?: number;
    cache?: boolean;
    chat?: boolean;
    internalPrompt?: boolean;
    arguments?: ArgumentSchema;
    tools?: string[];
    globalTools?: string[];
    globalModelName?: string;
    context?: string[];
    exportContext?: string[];
    export?: string[];
    agents?: string[];
    credentials?: string[];
    instructions?: string;
}
export interface ToolReference {
    named: string;
    reference: string;
    arg: string;
    toolID: string;
}
export declare const ToolType: "tool";
export interface Tool extends ToolDef {
    id: string;
    type: typeof ToolType;
    toolMapping?: Record<string, ToolReference[]>;
    localTools?: Record<string, string>;
    source?: SourceRef;
    workingDir?: string;
}
export interface SourceRef {
    location: string;
    lineNo: number;
    repo?: Repo;
}
export declare const TextType: "text";
export interface Text {
    id: string;
    type: typeof TextType;
    format: string;
    content: string;
}
export type Block = Tool | Text;
export declare enum RunState {
    Creating = "creating",
    Running = "running",
    Continue = "continue",
    Finished = "finished",
    Error = "error"
}
export declare enum ToolCategory {
    ProviderToolCategory = "provider",
    CredentialToolCategory = "credential",
    ContextToolCategory = "context",
    InputToolCategory = "input",
    OutputToolCategory = "output",
    NoCategory = ""
}
export interface RunFrame {
    id: string;
    type: RunEventType.RunStart | RunEventType.RunFinish;
    program: Program;
    input: string;
    output: string;
    error: string;
    start: string;
    end: string;
    state: RunState;
    chatState: any;
}
export interface Call {
    toolID: string;
    input?: string;
}
export interface Output {
    content?: string;
    subCalls: Record<string, Call>;
}
export interface InputContext {
    toolID: string;
    content: string;
}
export interface Usage {
    promptTokens: number;
    completionTokens: number;
    totalTokens: number;
}
export interface CallFrame {
    id: string;
    tool?: Tool;
    agentGroup?: ToolReference[];
    currentAgent?: ToolReference;
    displayText?: string;
    inputContext: InputContext[];
    toolCategory?: ToolCategory;
    toolName: string;
    parentID?: string;
    type: RunEventType.CallStart | RunEventType.CallChat | RunEventType.CallConfirm | RunEventType.CallContinue | RunEventType.CallSubCalls | RunEventType.CallProgress | RunEventType.CallFinish;
    start: string;
    end: string;
    input: Arguments;
    output: Output[];
    error?: string;
    usage: Usage;
    llmRequest?: any;
    llmResponse?: any;
}
export interface PromptFrame {
    id: string;
    type: RunEventType.Prompt;
    time: string;
    message: string;
    fields: string[];
    sensitive: boolean;
}
export type Frame = RunFrame | CallFrame | PromptFrame;
export interface AuthResponse {
    id: string;
    accept: boolean;
    message?: string;
}
export interface PromptResponse {
    id: string;
    responses: Record<string, string>;
}
export declare function getEnv(key: string, def?: string): string;
