import http from "http";
import path from "path";
import child_process from "child_process";
import { fileURLToPath } from "url";
import { gunzipSync } from "zlib";
function globalOptsToEnv(env, opts) {
    if (!opts) {
        return;
    }
    if (opts.APIKey) {
        env["OPENAI_API_KEY"] = opts.APIKey;
    }
    if (opts.BaseURL) {
        env["OPENAI_BASE_URL"] = opts.BaseURL;
    }
    if (opts.DefaultModel) {
        env["GPTSCRIPT_SDKSERVER_DEFAULT_MODEL"] = opts.DefaultModel;
    }
    if (opts.DefaultModelProvider) {
        env["GPTSCRIPT_SDKSERVER_DEFAULT_MODEL_PROVIDER"] = opts.DefaultModelProvider;
    }
}
export var RunEventType;
(function (RunEventType) {
    RunEventType["Event"] = "event";
    RunEventType["RunStart"] = "runStart";
    RunEventType["RunFinish"] = "runFinish";
    RunEventType["CallStart"] = "callStart";
    RunEventType["CallChat"] = "callChat";
    RunEventType["CallSubCalls"] = "callSubCalls";
    RunEventType["CallProgress"] = "callProgress";
    RunEventType["CallConfirm"] = "callConfirm";
    RunEventType["CallContinue"] = "callContinue";
    RunEventType["CallFinish"] = "callFinish";
    RunEventType["Prompt"] = "prompt";
})(RunEventType || (RunEventType = {}));
export class GPTScript {
    static serverURL = "";
    static serverProcess;
    static instanceCount = 0;
    ready;
    constructor(opts) {
        this.ready = false;
        GPTScript.instanceCount++;
        if (!GPTScript.serverURL) {
            GPTScript.serverURL = "http://" + (process.env.GPTSCRIPT_URL || "127.0.0.1:0");
        }
        if (GPTScript.instanceCount === 1 && process.env.GPTSCRIPT_DISABLE_SERVER !== "true") {
            let env = process.env;
            if (opts && opts.Env) {
                env = {};
                for (const v of opts.Env) {
                    const equalIndex = v.indexOf("=");
                    if (equalIndex === -1) {
                        env[v] = "";
                    }
                    else {
                        env[v.substring(0, equalIndex)] = v.substring(equalIndex + 1);
                    }
                }
            }
            globalOptsToEnv(env, opts);
            process.on("exit", (code) => {
                if (GPTScript.serverProcess) {
                    GPTScript.serverProcess.stdin?.end();
                    GPTScript.serverProcess.kill(code);
                }
            });
            GPTScript.serverProcess = child_process.spawn(getCmdPath(), ["sys.sdkserver", "--listen-address", GPTScript.serverURL.replace("http://", "")], {
                env: env,
                stdio: ["pipe", "ignore", "pipe"]
            });
            GPTScript.serverProcess.stderr?.on("data", (data) => {
                let url = data.toString().trim();
                if (url.includes("=")) {
                    url = url.substring(url.indexOf("=") + 1);
                }
                GPTScript.serverURL = `http://${url}`;
                GPTScript.serverProcess.stderr?.removeAllListeners();
            });
        }
    }
    close() {
        GPTScript.instanceCount--;
        if (GPTScript.instanceCount === 0 && GPTScript.serverProcess) {
            GPTScript.serverURL = "http://" + (process.env.GPTSCRIPT_URL || "127.0.0.1:0");
            GPTScript.serverProcess.kill("SIGTERM");
            GPTScript.serverProcess.stdin?.end();
        }
    }
    listTools() {
        return this.runBasicCommand("list-tools");
    }
    listModels() {
        return this.runBasicCommand("list-models");
    }
    version() {
        return this.runBasicCommand("version");
    }
    async runBasicCommand(cmd) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand(cmd, "", {}, GPTScript.serverURL);
        r.requestNoStream(null);
        return r.text();
    }
    /**
     * Runs a tool with the specified name and options.
     *
     * @param {string} toolName - The name of the tool to run. Can be a file path, URL, or GitHub URL.
     * @param {RunOpts} [opts={}] - The options for running the tool.
     * @return {Run} The Run object representing the running tool.
     */
    async run(toolName, opts = {}) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        return (new Run("run", toolName, opts, GPTScript.serverURL)).nextChat(opts.input);
    }
    /**
     * Evaluates the given tool and returns a Run object.
     *
     * @param {ToolDef | ToolDef[]} tool - The tool to be evaluated. Can be a single ToolDef object or an array of ToolDef objects.
     * @param {RunOpts} [opts={}] - Optional options for the evaluation.
     * @return {Run} The Run object representing the evaluation.
     */
    async evaluate(tool, opts = {}) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        return (new Run("evaluate", tool, opts, GPTScript.serverURL)).nextChat(opts.input);
    }
    async parse(fileName) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("parse", fileName, {}, GPTScript.serverURL);
        r.request({ file: fileName });
        return parseBlocksFromNodes((await r.json()).nodes);
    }
    async parseTool(toolContent) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        const r = new RunSubcommand("parse", "", {}, GPTScript.serverURL);
        r.request({ content: toolContent });
        return parseBlocksFromNodes((await r.json()).nodes);
    }
    async stringify(blocks) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        const nodes = [];
        for (const block of blocks) {
            if (block.type === "tool") {
                nodes.push({
                    toolNode: {
                        tool: block
                    }
                });
            }
            else if (block.type === "text") {
                nodes.push({
                    textNode: {
                        text: "!" + (block.format || "text") + "\n" + block.content
                    }
                });
            }
        }
        const r = new RunSubcommand("fmt", "", {}, GPTScript.serverURL);
        r.request({ nodes: nodes });
        return r.text();
    }
    async confirm(response) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        const resp = await fetch(`${GPTScript.serverURL}/confirm/${response.id}`, {
            method: "POST",
            body: JSON.stringify(response)
        });
        if (resp.status < 200 || resp.status >= 400) {
            throw new Error(`Failed to confirm ${response.id}: ${await resp.text()}`);
        }
    }
    async promptResponse(response) {
        if (!this.ready) {
            this.ready = await this.testGPTScriptURL(20);
        }
        const resp = await fetch(`${GPTScript.serverURL}/prompt-response/${response.id}`, {
            method: "POST",
            body: JSON.stringify(response.responses)
        });
        if (resp.status < 200 || resp.status >= 400) {
            throw new Error(`Failed to respond to prompt ${response.id}: ${await resp.text()}`);
        }
    }
    async testGPTScriptURL(count) {
        while (count > 0) {
            try {
                await fetch(`${GPTScript.serverURL}/healthz`);
                return true;
            }
            catch {
                if (count === 0) {
                }
                await new Promise(r => setTimeout(r, 500));
                count--;
            }
        }
        throw new Error("Failed to wait for gptscript to be ready");
    }
}
export class Run {
    id;
    opts;
    tools;
    state = RunState.Creating;
    calls = {};
    err = "";
    stdout;
    gptscriptURL;
    requestPath = "";
    promise;
    req;
    stderr;
    callbacks = {};
    chatState;
    parentCallId = "";
    prg;
    respondingToolId;
    constructor(subCommand, tools, opts, gptscriptURL) {
        this.id = randomId("run-");
        this.requestPath = subCommand;
        this.opts = opts;
        this.tools = tools;
        this.gptscriptURL = gptscriptURL;
    }
    nextChat(input = "") {
        if (this.state !== RunState.Continue && this.state !== RunState.Creating && this.state !== RunState.Error) {
            throw (new Error(`Run must in creating, continue or error state, not ${this.state}`));
        }
        let run = this;
        if (run.state !== RunState.Creating) {
            run = new this.constructor(this.requestPath, this.tools, this.opts, this.gptscriptURL);
        }
        if (this.chatState && this.state === RunState.Continue) {
            // Only update the chat state if the previous run didn't error.
            // The chat state on opts will be the chat state for the last successful run.
            this.opts.chatState = this.chatState;
        }
        run.opts.input = input;
        if (Array.isArray(this.tools)) {
            run.request({ toolDefs: this.tools, ...this.opts });
        }
        else if (typeof this.tools === "string") {
            run.request({ file: this.tools, ...this.opts });
        }
        else {
            // In this last case, this.tools is a single ToolDef.
            run.request({ toolDefs: [this.tools], ...this.opts });
        }
        return run;
    }
    processStdout(data) {
        if (typeof data === "string") {
            if (data.trim() === "") {
                return "";
            }
            try {
                data = JSON.parse(data);
            }
            catch (e) {
                return data;
            }
        }
        const out = data;
        if (out.done === undefined || !out.done) {
            this.chatState = JSON.stringify(out.state);
            this.state = RunState.Continue;
            this.respondingToolId = out.toolId;
        }
        else {
            this.state = RunState.Finished;
            this.chatState = undefined;
        }
        return "";
    }
    request(tool) {
        if (!this.gptscriptURL) {
            throw new Error("request() requires gptscriptURL to be set");
        }
        const options = this.requestOptions(this.gptscriptURL, this.requestPath, tool);
        options.headers = { "Transfer-Encoding": "chunked", ...options.headers };
        this.promise = new Promise(async (resolve, reject) => {
            let frag = "";
            this.req = http.request(options, (res) => {
                this.state = RunState.Running;
                res.on("data", (chunk) => {
                    for (let line of (frag + chunk.toString()).split("\n")) {
                        const c = line.replace(/^(data: )/, "").trim();
                        if (!c) {
                            continue;
                        }
                        if (c === "[DONE]") {
                            return;
                        }
                        let e;
                        try {
                            e = JSON.parse(c);
                        }
                        catch {
                            frag = c;
                            return;
                        }
                        if (e.stderr) {
                            this.stderr = (this.stderr || "") + (typeof e.stderr === "string" ? e.stderr : JSON.stringify(e.stderr));
                            frag = "";
                        }
                        else if (e.stdout) {
                            frag = this.processStdout(e.stdout);
                        }
                        else {
                            frag = this.emitEvent(c);
                        }
                    }
                });
                res.on("end", () => {
                    if (this.state === RunState.Running || this.state === RunState.Finished || this.state === RunState.Continue) {
                        if (this.stdout) {
                            if (this.state !== RunState.Continue) {
                                this.state = RunState.Finished;
                            }
                            resolve(this.stdout);
                        }
                        else {
                            this.state = RunState.Error;
                            reject(this.stderr);
                        }
                    }
                    else if (this.state === RunState.Error) {
                        reject(this.err);
                    }
                });
                res.on("aborted", () => {
                    if (this.state !== RunState.Finished && this.state !== RunState.Error) {
                        this.state = RunState.Error;
                        this.err = "Run has been aborted";
                        reject(this.err);
                    }
                });
                res.on("error", (error) => {
                    if (this.state !== RunState.Error) {
                        this.state = RunState.Error;
                        this.err = error.message || "";
                    }
                    reject(this.err);
                });
            });
            this.req.on("error", (error) => {
                if (this.state !== RunState.Error) {
                    this.state = RunState.Error;
                    this.err = error.message || "";
                }
                reject(this.err);
            });
            this.req.write(JSON.stringify({ ...tool, ...this.opts }));
            this.req.end();
        });
    }
    requestNoStream(tool) {
        if (!this.gptscriptURL) {
            throw new Error("request() requires gptscriptURL to be set");
        }
        const options = this.requestOptions(this.gptscriptURL, this.requestPath, tool);
        if (tool) {
            options.body = { ...tool, ...this.opts };
        }
        const req = new Request(this.gptscriptURL + "/" + this.requestPath, options);
        this.promise = new Promise(async (resolve, reject) => {
            fetch(req).then(resp => resp.json()).then(res => resolve(res.stdout)).catch(e => {
                reject(e);
            });
        });
    }
    requestOptions(gptscriptURL, path, tool) {
        let method = "GET";
        if (tool) {
            method = "POST";
        }
        const url = new URL(gptscriptURL);
        return {
            hostname: url.hostname,
            port: url.port || 80,
            protocol: url.protocol || "http:",
            path: "/" + path,
            method: method,
            headers: {
                "Content-Type": "application/json"
            },
        };
    }
    on(event, listener) {
        if (!this.callbacks[event]) {
            this.callbacks[event] = [];
        }
        this.callbacks[event].push(listener);
        return this;
    }
    text() {
        if (this.err) {
            throw new Error(this.err);
        }
        if (!this.promise) {
            throw new Error("Run not started");
        }
        return this.promise;
    }
    async json() {
        return JSON.parse(await this.text());
    }
    currentChatState() {
        return this.chatState;
    }
    parentCallFrame() {
        if (this.parentCallId) {
            return this.calls[this.parentCallId];
        }
        return undefined;
    }
    program() {
        return this.prg;
    }
    respondingTool() {
        return this.respondingToolId ? this.prg?.toolSet[this.respondingToolId] : undefined;
    }
    close() {
        if (this.req) {
            this.req.destroy();
            return;
        }
        throw new Error("Run not started");
    }
    emitEvent(data) {
        for (let event of data.split("\n")) {
            event = event.trim();
            if (!event) {
                continue;
            }
            let f;
            try {
                const obj = JSON.parse(event);
                if (obj.run) {
                    f = obj.run;
                }
                else if (obj.call) {
                    f = obj.call;
                }
                else if (obj.prompt) {
                    f = obj.prompt;
                }
                else {
                    return event;
                }
            }
            catch (error) {
                return event;
            }
            if (!this.state) {
                this.state = RunState.Creating;
            }
            if (f.type === RunEventType.Prompt && !this.opts.prompt) {
                this.state = RunState.Error;
                this.err = `prompt occurred when prompt was not allowed: Message: ${f.message}\nFields: ${f.fields}\nSensitive: ${f.sensitive}`;
                this.close();
                return "";
            }
            if (f.type === RunEventType.RunStart) {
                this.state = RunState.Running;
                this.prg = f.program;
            }
            else if (f.type === RunEventType.RunFinish) {
                if (f.error) {
                    this.state = RunState.Error;
                    this.err = f.error || "";
                }
                else {
                    this.state = RunState.Finished;
                    this.stdout = f.output || "";
                }
            }
            else if (f.type.startsWith("call")) {
                f = f;
                if (!f.parentID && this.parentCallId === "") {
                    this.parentCallId = f.id;
                }
                this.calls[f.id] = f;
            }
            this.emit(RunEventType.Event, f);
            this.emit(f.type, f);
        }
        return "";
    }
    emit(event, data) {
        for (const cb of this.callbacks[event] || []) {
            cb(data);
        }
    }
}
class RunSubcommand extends Run {
    constructor(subCommand, tool, opts, gptscriptURL) {
        super(subCommand, tool, opts, gptscriptURL);
    }
    processStdout(data) {
        if (typeof data === "string") {
            this.stdout = (this.stdout || "") + data;
        }
        else {
            this.stdout = JSON.stringify(data);
        }
        return "";
    }
}
export const ArgumentSchemaType = "object";
export const PropertyType = "string";
export const ToolType = "tool";
export const TextType = "text";
export var RunState;
(function (RunState) {
    RunState["Creating"] = "creating";
    RunState["Running"] = "running";
    RunState["Continue"] = "continue";
    RunState["Finished"] = "finished";
    RunState["Error"] = "error";
})(RunState || (RunState = {}));
export var ToolCategory;
(function (ToolCategory) {
    ToolCategory["ProviderToolCategory"] = "provider";
    ToolCategory["CredentialToolCategory"] = "credential";
    ToolCategory["ContextToolCategory"] = "context";
    ToolCategory["InputToolCategory"] = "input";
    ToolCategory["OutputToolCategory"] = "output";
    ToolCategory["NoCategory"] = "";
})(ToolCategory || (ToolCategory = {}));
export function getEnv(key, def = '') {
    let v = process.env[key] || '';
    if (v == '') {
        return def;
    }
    if (v.startsWith('{"_gz":"') && v.endsWith('"}')) {
        try {
            return gunzipSync(Buffer.from(v.slice(8, -2), 'base64')).toString('utf8');
        }
        catch (e) {
        }
    }
    return v;
}
function getCmdPath() {
    if (process.env.GPTSCRIPT_BIN) {
        return process.env.GPTSCRIPT_BIN;
    }
    return path.join(path.dirname(fileURLToPath(import.meta.url)), "..", "bin", "gptscript" + (process.platform === "win32" ? ".exe" : ""));
}
function parseBlocksFromNodes(nodes) {
    const blocks = [];
    for (const node of nodes) {
        if (node.toolNode) {
            if (!node.toolNode.tool.id) {
                node.toolNode.tool.id = randomId("tool-");
            }
            blocks.push({
                type: "tool",
                ...node.toolNode.tool,
            });
        }
        if (node.textNode) {
            const format = node.textNode.text.substring(1, node.textNode.text.indexOf("\n")).trim() || "text";
            blocks.push({
                id: randomId("text-"),
                type: "text",
                format: format,
                content: node.textNode.text.substring(node.textNode.text.indexOf("\n") + 1).trim(),
            });
        }
    }
    return blocks;
}
function randomId(prefix) {
    return prefix + Math.random().toString(36).substring(2, 12);
}
//# sourceMappingURL=gptscript.js.map